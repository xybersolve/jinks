#!/usr/bin/env bash
# ================================================================
# -*- mode: bash -*-
# vi: set ft=sh
# ****************************************************************
#
# DESCRIPTION
#   Jenkins helper script
#    * start jenkins from war file
#    * backup and restore Jenkins
#
# SYNTAX & EXAMPLES
#    See 'SYNTAX' (below)
#
# ----------------------------------------------------------------
# IMPLEMENTATION
#    version         script 0.0.4
#    author          Greg Milligan
#    copyright       Copyright (c) 2017 http://www.xybersolve.com
#    license         GNU General Public License
#
# ================================================================
#  DEBUG OPTION
#    set -n  # Uncomment to check your syntax, without execution.
#    set -x  # Uncomment to debug this shell script
#
# ---------------------------------------------------------------
#
# TODO: Refactor WAR backup & restore to dockerized backup & restore
# TODO: Finish docker-compose & make, i.e., map jenkins_home
# ****************************************************************


# ---------------------------------------
# CONFIGFURATION
# ---------------------------------------
# strict environment
set -o errexit  # exit on command error status
set -o nounset  # no unreadonlyd variables
set -o pipefail # failr on pipe failures
trap 'echo "Aborting due to errexit on line $LINENO. Exit code: ${?}" >&2' ERR

# ---------------------------------------
# GLOBAL VARIABLES
# ---------------------------------------
# booleans
declare -ir TRUE=1
declare -ir FALSE=0
# script info

declare -r PROGNAME="$(basename ${0})"
declare -r VERSION=0.0.1
declare -r SUBJECT=""
declare -r KEYS=""
declare -ri MIN_ARG_COUNT=1
declare -r SYNTAX=$(cat <<EOF

    Script: ${PROGNAME}
    Purpose:
    Usage: ${PROGNAME} [options]

    Options:
      --help:  help and usage

      Jenkin in Docker:
      --start|--run|--up: instantiate docker container
      --stop|--down: bring down docker container
      --clean: stop docker container & delete docker iamge
      --ssh: SSH into Jenkins container
      --logs: attach to docker container logs

      Volume:
      --commit: Commit jenkins_home data container to an image

      Backup & Restore jenkins_home:
      --backup: Backup Jenkins home directory
      --restore: Restore Jenkins directory
      --archives: View archive files

      Maintanence:
      --dist: Copy files from project to local script bin

    Examples:
      ${PROGNAME} --start --|
      ${PROGNAME} --run ----|-- all start Jenkins
      ${PROGNAME} --up -----|
      ${PROGNAME} --stop -----|
      ${PROGNAME} --down -----| -- all stop Jenkins
      ${PROGNAME} --restart
      ${PROGNAME} --clean
      ${PROGNAME} --logs

      Volume:
        ${PROGNAME} --commit

      Backup & Restore:
        ${PROGNAME} --backup
        ${PROGNAME} --restore

      Distribute (move files to script bin):
        ${PROGNAME} --dist

EOF
)

# files & directories
declare -r SCRIPT_DIR="$( dirname ${0} )"
declare -r CONFIG_FILE="${SCRIPT_DIR}/jinks.conf.sh"

# actions
# docker main
declare -i START=${FALSE}
declare -i STOP=${FALSE}
declare -i RESTART=${FALSE}
declare -i LOGS=${FALSE}
declare -i DOWN=${FALSE}
declare -i CLEAN=${FALSE}
declare -i SSH=${FALSE}
# volume
declare -i VOLUME_CREATE=${FALSE}
declare -i VOLUME_VIEW=${FALSE}
declare -i VOLUME_COMMIT=${FALSE}
declare -i VOLUME_PUSH=${FALSE}
# backup & restore
declare -i BACKUP=${FALSE}
declare -i RESTORE=${FALSE}
declare -i ARCHIVES=${FALSE}
declare -i VERSIONS=${FALSE}

declare -i DISTRIBUTE=${FALSE}

# flags
declare -i DRYRUN=${FALSE}

# global variables
declare HOME_DIR=''

# ---------------------------------------
# COMMON FUNCTIONS
# ---------------------------------------
usage() {
  echo "${SYNTAX}"
}

error() {
  printf "\n%s\n" "Error: ${1}"
}

die() {
  error "${1}"
  usage
  printf "\n\n"
  exit "${2:-1}"
}

show_help() {
  printf "\n\n"
  usage
  printf "\n\n"
  exit 0
}

# ---------------------------------------
# MAIN CODE GOES HERE
# ---------------------------------------
source "${CONFIG_FILE}" \
  || die "Unable to load config: ${CONFIG_FILE}" 1

__start() {

  docker run \
    --name "${JENKINS_CONTAINER}" \
    -u root \
    --rm \
    -d \
    -p 8080:8080 \
    --volumes-from "${JENKINS_HOME_CONTAINER}" \
    -v /var/run/docker.sock:/var/run/docker.sock \
    "${JENKINS_IMAGE}"
}

__restart() {
  docker container restart "${JENKINS_CONTAINER}"

}

__logs() {
  docker logs "${JENKINS_CONTAINER}"
}


__stop() {
  docker container stop "${JENKINS_CONTAINER}" || true
}

__clean() {
  __stop
  docker image rmi "${JENKINS_IMAGE}"
}


__create_volume() {
  # should only have to do this once
  # create volume in busybox container
  docker create -v /var/jenkins_home --name jenkins_home busybox
  # copy the local jenkins home directory into volume
  docker cp ~/.jenkins/. jenkins_home:/var/jenkins_home
}

__view_volume() {
  docker exec -it jenkins_home ls /var/jenkins_home
}

__commit_volume() {
  docker commit "${JENKINS_HOME_CONTAINER}" "${JENKINS_HOME_IMAGE}:latest"
}


__ssh() {
  docker exec -it "${JENKINS_CONTAINER}" bash
}

__open() {
  local host=$(docker-machine active)
  local ip=$(docker-machine ip ${host})
  open "http://${ip}:8080"
}

__check_home() {
  :
  # check if jenkins home directory was specified
  # create it if required
  # if [[ -n ${HOME_DIR} ]]; then
  #   JENKINS_HOME_DIR="${HOME_DIR}"
  # else
  #   echo "Jenkins home directory was not supplied";
  #   echo "Default will be used: ${JENKINS_HOME_DIR}";
  # fi
  #
  # [[ -d ${JENKINS_HOME_DIR} ]] \
  #   || mkdir -p "${JENKINS_HOME_DIR}"
}

__backup() {
  # backup the container volume to hard drive
  local datetime=$(date +%Y%m%d)
  local archive_dir="${ARCHIVE_DIR}/${datetime}"

  [[ -d "${archive_dir}" ]] || mkdir -p "${archive_dir}"
  docker cp ${JENKINS_VOLUME}:/var/jenkins_home "${archive_dir}"
  #__check_home
  # [[ -d ${ARCHIVE_DIR} ]] \
  #   || mkdir -p "${ARCHIVE_DIR}"
  #
  # if (( DRYRUN )); then
  #   echo
  #   echo "Back up Jenkins home directory"
  #   echo "From: ${JENKINS_HOME_DIR}"
  #   echo "To: ${archive_file}"
  #   echo
  # else
  #   cd "${JENKINS_HOME_DIR}"
  #
  #   tar -czf "${archive_file}" . &>/dev/null \
  #     && printf "\nüçÑ  Backed Jenkins up to:\n\t%s\n\n" "${archive_file}" \
  #     || printf "\n‚ò†Ô∏è  Failed to back up Jenkins to:\n\t%s\n\n" "${archive_file}"
  # fi
}

__restore() {
  local dest_dir
  local archive_file
  :
  # [[ -z ${FILENAME} ]] \
  #   && die "No archive file was specified, use --file=<filename>" 3
  #
  # archive_file="${ARCHIVE_DIR}/${FILENAME}"
  #
  # __check_home
  #
  # # check if the file is there
  # [[ -f "${archive_file}" ]] \
  #   || die "‚ò†Ô∏è  Unable to find archive: ${archive_file}" 2
  #
  # if (( DRYRUN )); then
  #   echo
  #   echo "Restore Jenkins home directory"
  #   echo "From: ${archive_file}"
  #   echo "To: ${JENKINS_HOME_DIR}"
  #   echo
  # else
  #   tar -xzf "${archive_file}" -C "${JENKINS_HOME_DIR}" \
  #     && printf "\nüçÑ  Restored Jenkins to:\n\t%s\n\n" "${JENKINS_HOME_DIR}" \
  #     || printf "\n‚ò†Ô∏è  Failed to restore Jenkins from:\n\t%s\n\n" "${archive_file}"
  # fi
}

__choose_restore() {
  # echo "${vers[@]}"
  # PS3="Select version to start: "
  # select ver in "${LOCAL_VERSIONS[@]}" "Abort"; do
  #   if [[  $ver = "Abort" ]]; then
  #     exit 0
  #   else
  #     # pull the key from the value
  #     JENKINS_VER=${ver}
  #     return
  #   fi
  # done
  :
}


__distribute() {
  # move files into script bin
  echo "Distribute ${PROGNAME}"

  local file=''
  local -r dest=~/bin
  local -ra files=(
    "${PROGNAME}"
    "${CONFIG_FILE}"
  )
  printf "\n"
  for file in "${files[@]}"; do
    cp "${file}" "${dest}" \
      && printf "üëçüèª  Copied: %s to %s\n" "${file}" "${dest}"
  done
  printf "\n"
}

__get_opts() {
  while (( $# > 0 )); do
    local arg="${1}"; shift;
    case ${arg} in
      --help)
        show_help
        ;;
      --start|--run|--up)
        START=${TRUE}
        ;;
      --stop|--down)
        STOP=${TRUE}
        ;;
      --restart)
        RESTART=${TRUE}
        ;;
      --logs)
        LOGS=${TRUE}
        ;;
      --clean)
        CLEAN=${TRUE}
        ;;
      --ssh)
        SSH=${TRUE}
        ;;
      --open)
        __open; exit 0;
        ;;
      --volume)
        VOLUME_CREATE=${TRUE}
        ;;
      --view)
        VOLUME_VIEW=${TRUE}
        ;;
      --backup)
        BACKUP=${TRUE}
        ;;
      --restore)
        RESTORE=${TRUE}
        ;;
      --commit)
        VOLUME_COMMIT=${TRUE}
        ;;
      --dist)
        DISTRIBUTE=${TRUE}
        ;;
      *) die "Unknown option: ${arg}" ;;
   esac
  done
  return 0
}

__dispatch() {
  (( START )) && __start
  (( STOP )) && __stop
  (( RESTORE )) && __restore
  (( RESTART )) && __restart
  (( SSH )) && __ssh
  (( LOGS )) && __logs
  (( DOWN )) && __down
  (( CLEAN )) && __clean

  # volume
  (( VOLUME_CREATE )) && __create_volume
  (( VOLUME_VIEW )) && __view_volume
  (( VOLUME_COMMIT )) && __commit_volume

  # backup
  (( BACKUP )) && __backup
  (( ARCHIVES )) && __view_archives
  (( DISTRIBUTE )) && __distribute


  return 0
}

__main() {
  (( ${#} < MIN_ARG_COUNT )) && die "Expects at least ${MIN_ARG_COUNT} arguments" 1
  (( $# > 0 )) && __get_opts "$@"

  __dispatch

  return 0
}
(( ${#} > 0 )) && __main "${@}" || __main

:<<'RESOURCES'
Jenkins war files

RESOURCES
